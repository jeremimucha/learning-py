from pathlib import Path
from unicodedata import name

from fastapi import FastAPI
from fastapi.responses import HTMLResponse
from pydantic import BaseModel

from charindex import InvertedIndex

# Elegant use of the overloaded `/` operator in pathlib
STATIC_PATH = Path(__file__).parent.absolute() / 'static'

# Define the ASGI app.
# The parameters shown are metadata for the autogenerated documentation.
app = FastAPI(
    title='Mojifinder Web',
    description='Search for Unicode characters by name.',
)

# `pydantic` schema for JSON response with char and name fields.
class CharName(BaseModel):
    char: str
    name: str

# Build the index and load the static HTML form, attaching
# both the app.state for later use.
def init(app):
    app.state.index = InvertedIndex()
    app.state.form = (STATIC_PATH / 'form.html').read_text()

# Run init when this module is loaded by the ASGI server.
init(app)

# Route for the /search endpoint; `response_model` uses that CharName
# pydantic model to describe the response format.
@app.get('/search', response_model=list[CharName])
# FastAPI assumes that any parameters that appear in the function
# or coroutine signature that are not in the route path will be
# passed in the HTTP query string, e.g. "/search?q=cat".
# Since `q` has no defualt, FastAPI will return a 422 (Unprocessable Entity)
# if `q` is missing from the query string.
async def search(q: str):
    chars = sorted(app.state.index.search(q))
    # Returning an iterable of dicts compatible with the response_model schema
    # allows FastAPI to build the JSON response according to the response_model
    # in the @app.get decorator.
    return ({'char': c, 'name': name(c)} for c in chars)

@app.get('/', response_class=HTMLResponse, include_in_schema=False)
# Regular functions - non-async - can also be used to produce responses.
def form():
    return app.state.form

# no main funcion  
# The module is loaded and driven by the ASGI server - `uvicorn` in this example.